/**
 * 
 * 
  
  数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。

  你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：

  将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
  将第 i 个筹码向左或者右移动 1 个单位，代价为 1。
  最开始的时候，同一位置上也可能放着两个或者更多的筹码。

  返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。

   

  示例 1：

  输入：chips = [1,2,3]
  输出：1
  解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。
  示例 2：

  输入：chips = [2,2,2,3,3]
  输出：2
  解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。
  // 题目有问题，这里的意思是 在第二个位置有3个筹码，在第3个位置有2个筹码
  // 为偶数的表示放在偶数位置的有一个，为奇数的表示放在奇数位置上的有一个，总的奇数个数为 num & 1 为 1的总数
  
  提示：
  1 <= chips.length <= 100
  1 <= chips[i] <= 10^9


 * 
 * 
 */

 // 贪心算法，移动步数最小，那么里面每一步都尽量是移动两步
 // 那么将奇数项移动到一个位置花费为0
 // 那么将偶数项移动到一个位置花费为0
 // 移动所有奇数到position[i] 所有偶数到position[i+1] 
 /**
 * @param {number[]} position
 * @return {number}
 */
var minCostToMoveChips = function(position) {
  var odd = 0,  even = 0
  for (let num of position) {
    if ( num & 1 ) {
      odd++
    } else {
      even++
    }
  }
  return Math.min(even, odd)
};